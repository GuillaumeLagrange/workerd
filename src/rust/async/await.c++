#include <workerd/rust/async/await.h>
#include <workerd/rust/async/lib.rs.h>

namespace workerd::rust::async {

// =======================================================================================
// ArcWakerAwaiter

ArcWakerAwaiter::ArcWakerAwaiter(
    FutureAwaiterBase& futureAwaiter, OwnPromiseNode nodeParam, kj::SourceLocation location)
    : Event(location),
      futureAwaiter(futureAwaiter),
      node(kj::mv(nodeParam)) {
  node->setSelfPointer(&node);
  node->onReady(this);
  // TODO(perf): If `this->isNext()` is true, can we immediately resume? Or should we check if
  //   the enclosing coroutine has suspended at least once?
}

ArcWakerAwaiter::~ArcWakerAwaiter() noexcept(false) {
  unwindDetector.catchExceptionsIfUnwinding([this]() {
    node = nullptr;
  });
}

// Validity-check the Promise's result, then fire the BaseFutureAwaiterBase Event to poll the
// wrapped Future again.
kj::Maybe<kj::Own<kj::_::Event>> ArcWakerAwaiter::fire() {
  kj::_::ExceptionOr<WakeInstruction> result;

  node->get(result);
  KJ_IF_SOME(exception, kj::runCatchingExceptions([this]() {
    node = nullptr;
  })) {
    result.addException(kj::mv(exception));
  }

  // We should only ever receive a WakeInstruction, never an exception. But if we do, propagate
  // it to the coroutine.
  KJ_IF_SOME(exception, result.exception) {
    futureAwaiter.internalReject(kj::mv(exception));
    return kj::none;
  }

  auto value = KJ_ASSERT_NONNULL(result.value);

  if (value == WakeInstruction::WAKE) {
    // This was an actual wakeup.
    futureAwaiter.armDepthFirst();
  } else {
    // All of our Wakers were dropped. We are awaiting the Rust equivalent of kj::NEVER_DONE.
  }

  return kj::none;
}

void ArcWakerAwaiter::traceEvent(kj::_::TraceBuilder& builder) {
  // FutureAwaiter will call our `tracePromise()`.
  futureAwaiter.traceEvent(builder);
}

void ArcWakerAwaiter::tracePromise(kj::_::TraceBuilder& builder) {
  if (node.get() != nullptr) {
    node->tracePromise(builder, true);
  }
}

// =================================================================================================
// RustPromiseAwaiter

// To own RustPromiseAwaiters, Rust needs to know the size and alignment of RustPromiseAwaiter. To
// that end, we use bindgen to generate an opaque FFI type of known size for RustPromiseAwaiter in
// await.h.rs.
//
// Our use of bindgen is non-automated, and the generated await.hs.rs file must be manually
// regenerated whenever the size and alignment of RustPromiseAwaiter changes. To remind us to do so,
// we have these static_asserts.
//
// If you are reading this because a static_assert fired:
//
//   1. Scroll down to find a sample `bindgen` command line invocation.
//   2. Run the command in this directory.
//   3. Read the new await.hs.rs and adjust the constants in these static_asserts with the new size
//      or alignment.
//   4. Commit the changes here with the new await.hs.rs file.
//
// It would be nice to automate this someday. `rules_rust` has some bindgen rules, but it adds a few
// thousand years to the build times due to its hermetic dependency on LLVM. It's possible to
// provide our own toolchain, but I became fatigued in the attempt.
static_assert(sizeof(GuardedRustPromiseAwaiter) == sizeof(uint64_t) * 17,
    "GuardedRustPromiseAwaiter size changed, you must re-run bindgen");
static_assert(alignof(GuardedRustPromiseAwaiter) == alignof(uint64_t) * 1,
    "GuardedRustPromiseAwaiter alignment changed, you must re-run bindgen");

// Notes about the bindgen command below:
//
//   - `--generate "types"` inhibits the generation of any binding other than types.
//   - We use `--allow-list-type` and `--blocklist-type` regexes to select specific types.
//   - `--blocklist-type` seems to be necessary if your allowlisted type has nested types.
//   - The allowlist/blocklist regexes are applied to an intermediate mangling of the types' paths
//     in C++. In particular, C++ namespaces are replaced with Rust module names. Since `async` is
//     a keyword in Rust, bindgen mangles the corresponding Rust module to `async_`. Meanwhile,
//     nested types are mangled to `T_Nested`, despite being `T::Nested` in C++.
//   - `--opaque-type` tells bindgen to generate a type containing a single array of words, rather
//     than named members which alias the members in C++.
//
// The end result is a Rust file which defines Rust equivalents for our selected C++ types. The
// types will have the same size and alignment as our C++ types, but do not provide data member
// access, nor does bindgen define any member functions or special functions for the type. Instead,
// we define the entire interface for the types in our `cxxbridge` FFI module.
//
// We do it this way because in our philosophy on cross-language safety, the only structs which both
// languages are allowed to mutate are those generated by our `cxxbridge` macro. RustPromiseAwaiter
// is a C++ class, so we don't let Rust mutate its internal data members.

#if 0

bindgen \
    --rust-target 1.83.0 \
    --disable-name-namespacing \
    --generate "types" \
    --allowlist-type "workerd::rust::async_::GuardedRustPromiseAwaiter" \
    --opaque-type ".*" \
    --no-derive-copy \
    ./await.h \
    -o ./await.h.rs \
    -- \
    -x c++ \
    -std=c++23 \
    -stdlib=libc++ \
    -Wno-pragma-once-outside-header \
    -I $(bazel info bazel-bin)/external/capnp-cpp/src/kj/_virtual_includes/kj \
    -I $(bazel info bazel-bin)/external/capnp-cpp/src/kj/_virtual_includes/kj-async \
    -I $(bazel info bazel-bin)/external/crates_vendor__cxx-1.0.133/_virtual_includes/cxx_cc \
    -I $(bazel info bazel-bin)/src/rust/async/_virtual_includes/async@cxx

#endif

RustPromiseAwaiter::RustPromiseAwaiter(OwnPromiseNode nodeParam, kj::SourceLocation location)
    : Event(location),
      node(kj::mv(nodeParam)),
      done(false) {
  node->setSelfPointer(&node);
  node->onReady(this);
}

RustPromiseAwaiter::~RustPromiseAwaiter() noexcept(false) {
  // Sever any promise tracing relationship before we destroy our PromiseNode.
  linkedGroup().invalidate();

  unwindDetector.catchExceptionsIfUnwinding([this]() {
    node = nullptr;
  });
}

kj::Maybe<kj::Own<kj::_::Event>> RustPromiseAwaiter::fire() {
  // Safety: Our Event can only fire on the event loop which was active when our Event base class
  // was constructed. Therefore, we don't need to check that we're on the correct event loop.

  done = true;

  KJ_IF_SOME(coAwait, linkedGroup().tryGet()) {
    coAwait.armDepthFirst();
    linkedGroup().invalidate();
  } else KJ_IF_SOME(waker, rustWaker) {
    waker.wake();
    rustWaker = kj::none;
  } else {
    // We were constructed, and our Event even fired, but our owner still didn't `poll()` us yet.
    // This is currently an unlikely case given how the rest of the code is written, but doing
    // nothing here is the right thing regardless: `poll()` will see `done == true` if/when it is
    // eventually called.
  }

  return kj::none;
}

void RustPromiseAwaiter::traceEvent(kj::_::TraceBuilder& builder) {
  if (node.get() != nullptr) {
    node->tracePromise(builder, true);
  }
  // TODO(now): This seems wrong ... this will trace back into me?
  KJ_IF_SOME(coAwait, linkedGroup().tryGet()) {
    coAwait.traceEvent(builder);
  }
}

void RustPromiseAwaiter::tracePromise(kj::_::TraceBuilder& builder) {
  if (node.get() != nullptr) {
    node->tracePromise(builder, true);
  }
}

bool RustPromiseAwaiter::poll_with_kj_waker(const KjWaker& waker) {
  // TODO(perf): If `this->isNext()` is true, meaning our event is next in line to fire, can we
  //   disarm it, set `done = true`, etc.? If we can only suspend if our enclosing KJ coroutine has
  //   suspended at least once, we may be able to check for that through KjWaker.

  if (done) {
    // TODO(now): Propagate value-or-exception.
    return true;
  }

  // Safety: const_cast is okay, because `waker.is_current()` means we are running on the same
  // event loop that the `waker.getFutureAwaiter()` Event is a member of, and we only use KjWaker
  // to access that Event.
  // TODO(now): Scope this mutable access tighter somehow.
  KJ_ASSERT(waker.is_current());
  auto& mutWaker = const_cast<KjWaker&>(waker);

  // TODO(now): Only re-link if it's a different FutureAwaiter.
  linkedGroup().set(mutWaker.getFutureAwaiter());
  rustWaker = kj::none;

  return false;
}

bool RustPromiseAwaiter::poll(const RustWaker* waker) {
  // TODO(perf): If `this->isNext()` is true, meaning our event is next in line to fire, can we
  //   disarm it, set `done = true`, etc.? If we can only suspend if our enclosing KJ coroutine has
  //   suspended at least once, we may be able to check for that through KjWaker, but this path
  //   doesn't have access to one.

  if (done) {
    // TODO(now): Propagate value-or-exception.
    return true;
  }

  // TODO(now): Pass RustWaker pointer at construction time, or assert it's the same as the
  //   previous one.
  linkedGroup().invalidate();
  rustWaker = waker;

  return false;
}

void guarded_rust_promise_awaiter_new_in_place(PtrGuardedRustPromiseAwaiter ptr, OwnPromiseNode node) {
  kj::ctor(*ptr, kj::mv(node));
}
void guarded_rust_promise_awaiter_drop_in_place(PtrGuardedRustPromiseAwaiter ptr) {
  kj::dtor(*ptr);
}

// =======================================================================================
// FutureAwaiterBase

FutureAwaiterBase::FutureAwaiterBase(
    kj::_::Event& next, kj::_::ExceptionOrValue& resultRef, kj::SourceLocation location)
    : Event(location),
      next(next),
      resultRef(resultRef) {}

void FutureAwaiterBase::internalReject(kj::Exception exception) {
  resultRef.addException(kj::mv(exception));
  next.armDepthFirst();
}

void FutureAwaiterBase::traceEvent(kj::_::TraceBuilder& builder) {
  auto elements = linkedObjects();
  if (elements.begin() != elements.end()) {
    elements.front().tracePromise(builder);
  } else KJ_IF_SOME(awaiter, arcWakerAwaiter) {
    awaiter.tracePromise(builder);
  }
  next.traceEvent(builder);
}

BoxFutureVoidAwaiter operator co_await(kj::_::CoroutineBase::Await<BoxFutureVoid> await) {
  return BoxFutureVoidAwaiter{await.coroutine, kj::mv(await.awaitable)};
}

BoxFutureVoidAwaiter operator co_await(kj::_::CoroutineBase::Await<BoxFutureVoid&> await) {
  return BoxFutureVoidAwaiter{await.coroutine, kj::mv(await.awaitable)};
}

}  // namespace workerd::rust::async
